Sarah Vectorization
Thomas if/else - mostly done needs some code touch-up
Thomas for, apply family - This is mostly done, needs some code touch up


#### Control Structures 
<h4> Control Structures</h4>
What are control structures? The simplest way to think about this is that these are programming elements that control the flow of data in your code dependng on the value of logical conditions. There are two control structures we are going to focus on: `for` loops and `ifelse` statements. `for` loops are a control structure that sets the number of times and the data code should perform an operation on. 'ifelse' statements control what code is run under different conditions. 

<h4> if/else Statements </h4>
Most of you are probably familiar with this. It has 3 pieces (in order):
  
  1.  A statement ("if") to evaluate as a (T/F), e.g. (x>1) 
  2.  An action to perform if it is TRUE  
  3.  An action to perform if it is FALSE
  
On any individual data point or set of data, only two of these code pieces will be applied. The if statement (1) will always be evaluated. Then only the appropriate T or F action (2 or 3) will be applied - the other will be skipped. There are a two different ways to invoke this in R and they do different things:

This is the 'vectorized' version - you might use this to recode data. 

`ifelse(test= , yes= , no= )`

This is not vectorized but is very useful where you need a 'switch'. This can evaluate complex data like a dataframe, but only as long as the output is a single boolean (TRUE or FALSE).

`if(...){}else{}`

Let's see how `ifelse` works to recode some data. 

```{r Day4Recode.1, echo=T, eval=F}
d<-c(1,2,3,4,100,200,300,400)
ifelse(d<mean(d)/10, "verify","OK")
```

Now, let's see what happens if we have some missing data.

```{r Day4Recode.2, echo=T, eval=F}
d<-c(1,2,3,4,100,200,300,400,NA)
ifelse(d<mean(d, na.rm=T)/10, "verify","OK")
help(ifelse) #so no surprises there...
```

That `NA`, gets passed through. Maybe we want that, but if we don't we can try to have two nested `ifelse` conditions. 

```{r Day4Recode.3, echo=T, eval=F}
ifelse(is.na(d)==T,"verify",
       ifelse(d<mean(d, na.rm=T)/10,"verify","OK"))
```       

Nesting is useful, but chances are if you find yourself nesting more than 2 or 3 conditions deep, there is probably a better way to do things. 

The next option is if...else
First thing to know about the if...else construction in R that it is very sensitive to the bracket placement, else must always be between a set of open brackets like this `}else{` . If it isn't you will end up with errors that are hard to track down. In context:

R will not comprehend this:

if(...){thing to do if TRUE<mark>}
      else{</mark>    
      thing to do if FALSE
      }

R will only comprehend this:

if(...){thing to do if TRUE
        <mark>}else{</mark>    
        thing to do if FALSE
        }

This statements expects a single boolean in the if() statement. Sometimes I like to use this to create switches or bypasses when I am writing loops/iteration. For example: If I have a dataframe that is non-empty, then do the analysis. If the data frame is empty do something else. 

```{r Day4Flagging.1, echo=T, eval=F}
d<-c(1:4,1:4*100,NA)
if(all(is.finite(d))){"no NA, NaN, or Inf present"
                     }else{"NA present"}
```

Simple enough, but not very helpful/informative. This also nests nicely and we will get back to that later, but here is what that looks like:

```{r Day4Flagging.1b, echo=T, eval=F}
d<-c(1:4,1:4*100)
if(!all(is.finite(d))){"NA present"
                     }else if(all(d<100)){"all items less than 100"
                     }else{paste(sum(d>100), "items more than 100")} 
```

I most commonly use the if...else construction to create a switch in the code for special handling of undesirable data. However, I usually only go to this if there isn't a more direct solution. In my mind, ifelse gives a false sense of security. What all is in that 'else'?

####Iteration

This brings us to iteration. Iteration is a control structure that causes code to repeat itself while the conditions for iterating are met. We will explain what that means a little later. Practically speaking it allows you to a lot of work without having to be the one doing it. Iteration consists of a few pieces:
  1. The data you need to do something to
  2. The method of iteration
  3. The task you need to do
  4. The result of your task
  
What are some kinds of tasks you find yourself doing that you are wanting to do more easily in R? 

There are a lot of ways to accomplish iteration and we are not going to cover them all. We are going to cover some of the most basic and commonly used approaches.

The first one you may be familiar with is the `for` loop. You give this a list of items and tell it what you want it to do and it will do that thing for each item on the list. In simplest terms that looks like:

`for(i in vector){ do thing 1
                do thing 2
                ...
                return output 
 }`

A few things to pick apart here:

i - i is an arbitrary variable, you could call it q. I will take on the value for the first item in the vector on the first step of iteration. It is passed into the loop code with a different value for each step of the iteration. 

vector - vector is that vector of items aka the conditions for iteration. These could be numeric or they could be characters or strings. Numeric vectors are common is you need to run through all of the cases. Character vectors are great if you have groups of data you want to work through. All `vector` does it gives it some instructions on what it should work on and effectively when to stop.

```{r ForLoop.1, echo=T, eval=F}

for(i in 1:9){                  #for the number 1 through 9
              OutDat<-i+1       #add 1 to each number and store that in the variable OutDat
              print(OutDat)     #print the result to console 
              }    
```
What we really want is the whole vector that generates. 
```{r ForLoop.1a, echo=T, eval=F}
#alternatively predefine a container to receive the data
OutDat<-NULL                    #define an empty variable
for(i in 1:9){
              OutDat[i]<-i+1    #store that in the ith position of the variable OutDat   
              }   
```

Before we move on to more interestig code, I want to pause and note that you will hear us tell you that there are better ways to iterate than a for_loop. However, for loops are a fundamental skill and almost everyone teaching these trainings will tell you that they will fall back on a for loop when they can't get something else to work.

So let's make a useful for loop. We are going to use the hobo data and we want to do 3 things with that. First we want to calculate some summary statistics, second we want to do a rudimentary QAQC check and flag potentially bad data, then we want to save it to a file so we can do some further visual assessment. That kind of task may sound familiar. I would note we are also going to write this as the 'do everything all at once' loop which is a pretty common way to start using a for loop. We will come back to whether or not that is the 'best' way to iterate a little later. 

```{r ForLoop.2, echo=TRUE, eval=TRUE}
library(magrittr);library(ggplot2)
fNames<-paste0("https://raw.githubusercontent.com/KateMMiller/IMD_R_Training_Intro/master/Data/",
             c("APIS01_20548905_2021_temp.csv",
               "APIS02_20549198_2021_temp.csv",
               "APIS03_20557246_2021_temp.csv",
               "APIS04_20597702_2021_temp.csv",
               "APIS05_20597703_2021_temp.csv")) 

OutPath<-choose.dir() #note, no trailing '\\' in path
TempUpper<-40
TempLower<-(-40)

#i=fNames[1] #code dev/debugging fragment
#rm(i) #debug.dev frag
SummaryData<-NULL #make sure this gets cleared before rerunning this code
for(i in fNames){d<-read.csv(i, skip=1, header=T)[1:3]
                  fName<-basename(i)
                  print(fName)#dev/debug frag
            #begin if...else control structure
                  if(nrow(d)>0){
            #What to do if there is at least 1 record in the dataframe
                  names(d)<-c("idx","DateTime","T_F")
                  d$DateTime2<-as.POSIXct(d$DateTime, "%m/%d/%y %H:%M:%S", tz="UCT")
            #summarize the data
                OutDat<-data.frame(FileName=fName,
                                   T_F_mean=mean(d$T_F, na.rm=T),
                                    T_F_min=min(d$T_F, na.rm=T),
                                    T_F_max=max(d$T_F, na.rm=T),
                                       nObs=nrow(d),
                                      nDays=(d$DateTime2[nrow(d)]-d$DateTime2[1])[[1]]) #days
            #Append new summary data to old summary data
                SummaryData<-rbind(SummaryData,OutDat) 
            #Do some QA/QC flagging
           d<-d%>%
              dplyr::mutate(TChangeFlag = ifelse(c(abs(diff(T_F, lag = 1)) > 10, FALSE), "D10", NA),
                     Flag = case_when(is.na(T_F) ~ "MISSING",
                                            T_F > TempUpper ~ "High",
                                            T_F < TempLower ~ "Low")) %>%
              tidyr::unite("Flag", c(TChangeFlag, Flag), sep = "_", remove = TRUE, na.rm = TRUE)
            #Write out the flagged dataset
             write.csv(d[,c("DateTime","T_F","Flag")],       
                        paste0(OutPath,"/",gsub(".csv","_QC.csv",fName)), 
                        row.names=F, quote=F)
            #Make some quick plots for visual QA/QC
                p<-ggplot(d, aes(x=DateTime2, y=T_F))+
                   geom_point(size=0.5)+
                   ggtitle(fname)
                ggsave(filename=gsub(".csv","_plot.pdf",fName), path=OutPath, device="pdf",
                       plot=p,  
                       width=5,height=5,units="in")
            #What to do when the dataframe is empty.
                }else{  
                     OutDat<-data.frame(FileName=fname,
                                        T_F_mean=NA,
                                         T_F_min=NA,
                                         T_F_max=NA,
                                            nObs=NA,
                                           nDays=NA)
            SummaryData<-rbind(SummaryData,OutDat)
                }
}
#write out the summary data. Not run, included for fun.
#write.csv(SummaryData, paste0(OutPath,"/SummaryData.csv"),row.names=F, quote=F)           


```
That is most of what you might end up doing in some routine QA/QC task. We can take some time now to deconstruct what in this is new to you and what questions you have on it. 

+ We used a control structure to handle potentially missing data

+ There are only rare instances where you want to wrap stuff up in that complicated of a for loop. The more complex the loop the harder it is to debug. Complex for loops are also hard to build flexibility into. 

+`for` is pretty hard to get data out of if you want to work with it further in the environment. It has probably been my single greatest frustration. You have to tell it exactly what to give you and set that up beforehand otherwise you aren't going to get anything. (okay fine, this is a good thing and a bad thing)  

+ ...


The good news is that there are many other ways to iterate in R. Often you will start with a for loop and then refine it with approaches that are more suited to your needs. One family of functions that often replaces "for" is the apply family of functions. 

`apply` - operates on things resembling a dataframe. Okay, really it operates on a matrix where all values are the same type (all number or all letters). It can operate by row or by column and the output will be a dataframe,

`mapply` - Is a way to vectorize a function that isn't vectorized. I don't think I have used this in the past year, but it is in the apply family and you might encounter it. 

`lapply` - Apparently, this is a special case of mapply and it operates on lists of things and `stores` the output in a list of things. sapply and vapply are variations on this theme.

`tapply` - apply by groups. This lets you apply functions by a group. So, quick summary statistics, but you will quickly outgrow this and there are better ways to do this. 

We are going to focus on apply and lapply. 
`apply` - Going back to that definition, when might you use it?
  
 Let's calculate the mean value for each site across sampling years
```{r ApplyFamily.1, echo=TRUE, eval=TRUE}
apply(d[],MARGIN=1, FUN=mean)
#need data still
``` 
 Now, let's calculate the mean value for each sampling year across sites
```{r ApplyFamily.1, echo=TRUE, eval=TRUE}   
     apply(d[],MARGIN=2, FUN=mean)
#need data still
```

Let's change gears a little bit. Let's look at lapply. Let's review what a list is really quick, a list is a container that can hold a bunch of different things and let them be different without trying to make them the same. They can have different numbers of columns, different numbers of rows, etc. They are like a filing cabinet.  I use them for reading in acoustic recognizer results, temperature results, etc. We are going to look at the case of reading in multiple CSV hobo files. 

In the previous for loop we operated on our hobos one at a time. What we can do instead is open all of the data into an object and operate it on it as needed. 

You should still have fname hanging out somewhere. This is that list of hobos. 

```{r ApplyFamily.3, echo=TRUE, eval=TRUE}
fNames
```

What we will do next is iterate through that list of names and store it in a list. We do that with lapply.

```{r ApplyFamily.4, echo=TRUE, eval=FALSE}
HoboList<-lapply(fNames,read.csv, skip=1, header=T)%>% #read hobo data into a list
          lapply(.,"[",,1:3)%>% #Grab only first 3 columns
          lapply(.,setNames, c("idx","DateTime","T_F")) #fix column names

#check to see if we can make this a purrr example?
```

So now all of those hobo files are available in this list and we made it pretty. So let's redo that previous for loop as an lapply.

First we can create that summary data

```{r ApplyFamily.5, echo=TRUE, eval=FALSE}
OutDat<-lapply(HoboList, function(x){data.frame(gmean=mean(),
                                     gmin=min(),
                                     gmax=max(),
                                     nObs=nrow()
                                    nDays=(...posix math...)
                                    )
               })
#insert some simplification step
write.csv(outDat, file.choose(), row.names=F, quote=F)
```

We can then do the flagging step

```{r ApplyFamily.6, echo=TRUE, eval=TRUE}
lapply(HoboList, function(x){
 #put that mutate-unite thing in here                
}
)
#need to put in the on the fly naming with the orignal file names.
```
Finally we can do some plotting. 
```{r ApplyFamily.7, echo=TRUE, eval=TRUE}
          library(ggplot2)
  lapply(HoboList, function(x){
                p<-ggplot(x, aes(x=DateTime, y=T_F))+
                   geom_point()+
                   ggtitle()
                ggsave(filename=  ,path=  ,plot=p, device="pdf", width=5,height=5,units="in")
                            
                #still some stuff to fix here. filename is not defined in the list. List needs to be named.
                   }
          )
```

So how is this different from the super for loop that does everything? 
-All of the data are available to you in 1 object. But, you could write a for loop that puts the data in a list.  
-You can easily add extra steps/iteration without worring about compatibility with the existing for loop. 
-You are invoking things in separate steps. You could do this by writing a series of for loops that do specific things but then you will be calling in the data each time.
-Better control of outputs if you need to tweak one part. If nothing else changed you shouldn't be running the whole thing again. 
-Note we secretly are getting you to start thinking about 'functional programming'. Each of these code chunks is a very short step away from being a function. 

Let's say you don't like the list structure and you need to crate a dataframe (e.g. for a multi-panel GGplot). It is pretty simple to collapse a list into a dataframe assuming you are collapsing things that are equivalent dimensions.

```{r ApplyFamily.8, echo=TRUE, eval=TRUE}
do.call(rbind, HoboList) 
```

And do.call was another example of iteration. That just took all of our files and glued them together instead of having to loop thorugh them and put them together one by one or call separate isntances of rbind. Of course you will want to make sure you know what each list element was before you glue them together.

  -purrr - This exists and I know nothing about it. Covered more in depth on day 6 

##### Vectorization

On the first day of this class, we introduced vectors. Here are some examples:

```{r VectorExamplesDay4, echo=TRUE, eval=TRUE}
# Numeric vectors
numbers <- 1:10
other_numbers <- 6:15

# Character vectors
code_lang <- c("R", "C++", "Java", "Python", "C")
human_lang <- c("English", "Spanish", "Chinese", "Russian")
```

What if we want to multiply `numbers` by two? Based on what we just learned about loops and apply functions, it might be tempting to do something like this:

```{r VectorLoop, echo=TRUE, eval=TRUE}
new_numbers <- c()  # Create a new NULL vector

for (num in numbers) {
  new_numbers <- c(new_numbers, 2 * num)
}

new_numbers
```

Or this:

```{r VectorApply, echo=TRUE, eval=TRUE}
new_numbers <- sapply(numbers, function(x){2 * x})
new_numbers
```

Clearly both of these solutions produce the correct result, but we're actually making this harder than it needs to be. It turns out that many functions and operations in R are *vectorized*, meaning that they will be applied in parallel to each element of a vector. So in this example, all we need to do to multiply each element in `numbers` by two is:

```{r VectorMult, echo=TRUE, eval=TRUE}
new_numbers <- numbers * 2
new_numbers
```

Division, addition, and subtraction are also vectorized:

```{r VectorOps, echo=TRUE, eval=TRUE}
numbers
numbers + 5
numbers - 3
numbers / 2
```

In fact, this even works with two or more vectors.

```{r TwoVectorOps, echo=TRUE, eval=TRUE}
numbers
other_numbers

other_numbers - numbers
other_numbers * numbers
```

So far we've only looked at operations between vectors and single values or two vectors of the same length. But what happens if we try to add two vectors of different lengths? Let's try it out.

```{r DiffVectorLengths, echo=TRUE, eval=TRUE}
ones <- rep(1, 6)  # Vector of 1's, length 6
ones

add_this <- c(1, 2)
this_one_breaks <- c(1, 2, 3, 4)

ones + add_this  # This works fine
ones + this_one_breaks  # This breaks
```

So what happened? When we added the vector `[1, 2]` to the vector `[1, 1, 1, 1, 1, 1]`, we got `[2, 3, 2, 3, 2, 3]`. When we added `[1, 2, 3, 4]` to `[1, 1, 1, 1, 1, 1]`, we got a result, but we also got a warning along with it. The text of the warning actually gives a clue as to what R is doing. It says "longer object length is not a multiple of shorter object length" because when R tries to operate on vectors of different lengths, it repeats the shorter vector until it matches the length of the longer vector.
`ones` is a vector of length 6. Since `add_this` is length 2 and 2 is a multiple of 6, R adds `[1, 1, 1, 1, 1, 1] + [1, 2, 1, 2, 1, 2]`, repeating `add_this` exactly three times. However, `this_one_breaks` is a vector of length 4, which is not a multiple of 6. Therefore, we get a warning because R cannot fit `this_one_breaks` into a vector of length 6 without truncating it.

**Consider mentioning how to do matrix math if you don't want vectorization

    -gsub, grep family (avoid regex)
    -basic vector math
      -rowsums vs colsums
    -inequalities  ==, <, >, %in%
    -& , |, (maybe get into &&, || )

-other control structures to be aware of.

NOT FOR TAB: Break to discuss other hard questions from previous days - especially how you integrate it into iteration.
